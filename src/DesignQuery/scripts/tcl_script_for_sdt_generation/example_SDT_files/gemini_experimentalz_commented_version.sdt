/*
 * Copyright (c) 2022 Rapid Silicon.
 * All rights reserved.
 *
 * Author:
 *       Tony McDowell <tony.mcdowell@rapidsilicon.com>
 *
 * SPDX-License-Identifier: BSD-3-Clause
 */

/dts-v1/;

/ {

	/* This file has comments for explanations */
	/*  https://elinux.org/Device_Tree_Usage  */

	compatible = "rapidsi,gemini";
	#address-cells = <0x2>;
	#size-cells = <0x2>;
	/* Where is reg in the nodes below? So dont have addresses and sizes in the root node like in the sdt document Z 
	   Nope, like in some examples some nodes dont have ranges field even though there are address and size fields specified in the parent nodes
	
	   The label 'intc:' has been added to the interrupt controller node, and the label was used to assign a phandle to the interrupt-parent property in the root node. This interrupt-parent value becomes the default for the system because all child nodes inherit it unless it is explicitly overridden.

	   #interrupt-cells is 2, so each interrupt specifier has 2 cells. This example uses the common pattern of using the first cell to encode the interrupt line number, and the second cell to encode flags such as active high vs. active low, or edge vs. level sensitive. For any given interrupt controller, refer to the controller's binding documentation to learn how the specifier is encoded.

	   intc: interrupt-controller@10140000 {
	          compatible = "arm,pl190";
	          reg = <0x10140000 0x1000 >;
	          interrupt-controller;
	          #interrupt-cells = <2>;
	      };

	    spi@10115000 {
	            compatible = "arm,pl022";
	            reg = <0x10115000 0x1000 >;
	            interrupts = < 4 0 >;
	        };


	*/
	model = "Rapid Silicon Internal Board";

	/* Application CPU configuration */
	cpus {
		#address-cells = <0x1>;
		#size-cells = <0x0>;
		/* Where is reg here? Z */
		
		cpu@0 {
			device_type = "cpu";
			reg = <0x00000000>;
			status = "okay";
			compatible = "riscv";
			riscv,isa = "rv32e";
			
		};
	
	};

	/* awesome cpu and cpu cluster sdt examples here: 
		https://www.kernel.org/doc/Documentation/devicetree/bindings/arm/cpus.txt 
		https://android.googlesource.com/kernel/msm.git/+/android-msm-shamu-3.10-lollipop-mr1/Documentation/devicetree/bindings/arm/topology.txt

	   Awesome device binding sdt stuff... inshort we have to defined a node and its compatible properties in a sdt binding file which is a yml or yaml or anyother file.. e.g., there is no device binding documentation for cpu-cluser node.. so we will have to define its compatible properties and requirements in the device binding documents:
	   	https://stackoverflow.com/questions/70947522/is-it-possible-to-have-arbitrary-data-in-a-zephyr-device-tree-node
	   	https://docs.zephyrproject.org/latest/build/dts/bindings-intro.html
	   	https://docs.zephyrproject.org/latest/build/dts/bindings.html
	   		WRONG.. there is official cpu-cluster node name here:
	   			https://static.linaro.org/connect/lvc20/presentations/LVC20-314-0.pdf
	   			CPU cluster on slide 8 here as well but in a different config
	   			great sdt example at slide-13 	 
	*/
	
	/* Boot CPU configuration */
	bcpu: cpus-cluster@0 {  /*  so I believe this bcpu is the "phandle" for default bboot cpu cluster config? */
		#address-cells = <0x1>;
		#size-cells = <0x0>;
		/* Where is reg here? Z */
		compatible = "cpus, cluster";
		
		cpu@0 {
			device_type = "cpu";
			reg = <0x00000000>;
			status = "okay";
			compatible = "riscv";
			riscv,isa = "rv32e";
			
		};		
	}
	
	/* AMBA/AXI resources found in the GEMINI PSS */
	amba_pss {
		compatible = "simple-bus";
		#address-cells = <0x2>;
		#size-cells = <0x2>;
		ranges;
		
	
	};
	
	/* AMBA/AXI resources found in the FPGA region */
	amba_fpga {
		compatible = "simple-bus";
		#address-cells = <0x2>;
		#size-cells = <0x2>;
		ranges;
		
	
	};

};



